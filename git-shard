#!/bin/bash
# shellcheck disable=SC2155

set -euo pipefail
# set -x


MAINREPO=$(git rev-parse --show-toplevel)
MAINREPOGIT=$(git rev-parse --git-dir)
if [[ "${OS:-}" == "Windows_NT" ]]; then
	MAINREPO="$(cygpath -u "$MAINREPO")"
	MAINREPOGIT="$(cygpath -u "$MAINREPOGIT")"
fi

function git-main(){
	git --git-dir="$MAINREPOGIT" "$@"
}
function git-sub(){
	local shard_path="$1"
	shift
	git --git-dir="$MAINREPOGIT/shards/$shard_path" --work-tree="$MAINREPO/$shard_path" "$@"
}

function get-shards-path(){
	while read -r SHARD; do
		echo "$SHARD" | sed -E 's|^shards\.(.*)\.upstream=.*|\1|'
	done <<< "$(git-main config --local -l | grep -E '^shards\..*\.upstream' || true)"
}

function get-shard-exists(){
	local shard_path="$1"
	if [[ "$shard_path" == "*" ]]; then
		if git-main config --local -l | grep -E '^shards\..*\.upstream' >/dev/null; then
			echo 1
		else
			echo 0
		fi
	else
		if git-main config --local "shards.$shard_path.upstream"; then
			echo 1
		else
			echo 0
		fi
	fi
}
function get-oldest-commit(){
	# TODO: find a cleaner solution for returning the oldest commit
	if [ -z "$1" ] || { [ -n "$2" ] && [ -n "$(git-main log "$1..$2")" ] ; }; then
		echo "$1"
	else
		echo "$2"
	fi
}
function get-latest-commit(){
	# TODO: find a cleaner solution for returning the latest commit
	if [ -z "$1" ] || { [ -n "$2" ] && [ -n "$(git-main log "$1..$2")" ] ; }; then
		echo "$2"
	else
		echo "$1"
	fi
}

function get-shard-commit(){
	local shard_path="$1"
	shift

	local last_inspected=$(git-main config --local "shards.$shard_path.commit")
	local last_commited=$(git-sub "$shard_path" show HEAD -q --format='%b' 2>/dev/null | grep -oE "^SHARD-MAINREF: \w+$" | cut -d ' ' -f 2 || true)

	local latest=$(get-latest-commit "$last_inspected" "$last_commited")
	if [ -z "$latest" ]; then
		git-main rev-parse HEAD^
	else
		echo "$latest"
	fi
}

function expand-shard-match(){
	if [[ "$1" == "*" ]]; then
		get-shards-path
	else
		echo "$1"
	fi
}

function migrate-commits(){

	local commit_from=""
	local commit_to="HEAD"
	local commit_args=()

	while (( $# > 0 )); do
		case "$1" in
			-h|-\?|--help)
				echo "Usage: $(basename "$0") commit [options]"
				exit 1
				;;
			--from)
				shift
				commit_from="$1"
				;;
			--to)
				shift
				commit_to="$1"
				;;
			*)
				commit_args+=("$1")
				;;
		esac

		shift
	done

	if [ -z "$commit_from" ]; then
		# Find oldest commit
		local commit_from="HEAD"

		while read -r SHARDPATH; do
			local COMMIT=$(get-shard-commit "$SHARDPATH")

			if [ -z "$commit_from" ] || [[ $(get-oldest-commit "$commit_from" "$COMMIT") == "$COMMIT" ]]; then
				local commit_from=$COMMIT
			fi
		done <<< "$(get-shards-path)"
	fi

	# List commits to copy to shard repositories
	local commits_to_inspect=$(git-main log --format="%H" "$commit_from..$commit_to" | tac)
	if [ -z "$commits_to_inspect" ]; then
		echo "Not commits to replicate on shards"
		exit 0
	fi

	# Stash changes if any
	if [ -n "$(git-main status --porcelain)" ]; then
		git-main stash push -u -m "Pre git-shard commit cleaning"
		trap "git-main stash pop -q" EXIT
	fi

	local mainrepo_branch=$(git-main branch --show-current)


	# Checkout and replicate each commit in each shard
	for HASH in $commits_to_inspect; do
		echo "=========================================="
		echo "Copying commit $(git-main show -s --format='%s (%h)' "$HASH") to shards"
		echo "=========================================="
		git-main checkout "$HASH" 2>/dev/null

		local commitinfo=$(git-main show "$HASH" -s --format='%an <%ae>%n%at%n%B')
		local commitinfo_len=$(wc -l <<< "$commitinfo")

		local commit_auth=$(sed '1q;d' <<< "$commitinfo")
		local commit_date=$(sed '2q;d' <<< "$commitinfo")
		local commit_msg=$(tail -n$(( commitinfo_len - 2 )) <<< "$commitinfo")
		local commit_msg=$(printf "%s\n\nSHARD-MAINREF: %s" "$commit_msg" "$HASH")

		local shard_path
		while read -r shard_path; do
			echo "=> $shard_path"
			if [[ "$(get-latest-commit "$(get-shard-commit "$shard_path")" "$HASH")" == "$HASH" ]]; then

				local files=$(git-main config --local "shards.$shard_path.files" || true)
				if [ -n "$files" ]; then
					local file
					while read -r file; do
						echo "ADDING FILE '$file'"
						git-sub "$shard_path" add "$file"
					done <<< "$(tr ":" "\n" <<< "$files")"
				else
					git-sub "$shard_path" add .
				fi

				if [ -n "$(git-sub "$shard_path" diff --staged --name-only)" ]; then
					git-sub "$shard_path" commit \
						--author="$commit_auth" --date="$commit_date" \
						--message="$commit_msg" \
						"${commit_args[@]}"
				else
					echo "  Not affected"
				fi
			else
				echo "  Commit already copied"
			fi


			git-main config --local "shards.$shard_path.commit" "$HASH"
		done <<< "$(get-shards-path)"
	done

	if [ -n "$mainrepo_branch" ]; then
		git-main checkout "$mainrepo_branch"
	fi
}









SUBCOMMAND="${1:-help}"
case "$SUBCOMMAND" in -h|--help|help)
	echo "Usage: git shard subcommand [options]"
	echo
	echo "Available subcommand:"
	echo " init   Register a directory as a shard and initialize/clone its associated git repository"
	echo " list   List all registered shards"
	echo " remove Un-register shards"
	echo " files  Limit an existing shard to a set of files and directories"
	echo " commit Copy commits from the main repository to each shard"
	echo " exec   Executes a git command inside a shard (do not repeat the 'git' command)"
	echo " help   Display this message"
	exit 0
esac

shift

case "$SUBCOMMAND" in
	init)
		case "${1:-help}" in -h|--help|help)
			echo "Usage: git shard init shard_path [upstream_url]"
			echo
			echo "Register a directory as a shard and initialize/clone its associated git repository."
			echo "The shard is versioned using a bare repository stored in .git/shards/"
			echo
			echo "Arguments:"
			echo " shard_path    Path of the shard"
			echo " upstream_url  Git clone URL if the shard repository has already been published"
			exit 0
		esac
		# Add a new shard
		SHARDPATH="$1"
		UPSTREAM="${2:-}"

		# Assertions
		[ -d "$SHARDPATH" ] || (echo "$SHARDPATH does not exist / is not a directory" && exit 1)
		(( $(get-shard-exists "$SHARDPATH") == 0 )) || (echo "A shard already exists for path $SHARDPATH" && exit 1)

		SHARDPATH=$(realpath --relative-to="$MAINREPO" "$SHARDPATH")
		SHARDSTORPATH="$MAINREPOGIT/shards/$SHARDPATH"

		# Clone/create shard repository
		mkdir -p "$SHARDSTORPATH"
		if [[ "$UPSTREAM" != "" ]]; then
			git clone --bare "$UPSTREAM" "$SHARDSTORPATH"

			LAST_MAIN_COMMIT=$(git-sub "$SHARDPATH" show HEAD -q --format='%b' | grep -oE "^SHARD-MAINREF: \w+$" | cut -d ' ' -f 2)
			git-main config --local "shards.$SHARDPATH.commit" "$LAST_MAIN_COMMIT"
		else
			git init --bare "$SHARDSTORPATH"
			git-main config --local "shards.$SHARDPATH.commit" ""
		fi

		# Add shard to git config
		git-main config --local "shards.$SHARDPATH.upstream" "$UPSTREAM"

		echo "Added shard $SHARDPATH"
		;;

	list)
		while read -r SHARD_PATH; do
			echo "$SHARD_PATH=>$(git-main config --local --get "shards.$SHARD_PATH.upstream")"
		done <<< "$(get-shards-path)"
		;;

	remove)
		case "${1:-help}" in -h|--help|help)
			echo "Usage: git shard remove shard_path [more_shard_path...]"
			echo
			echo "Un-register one or more shards and remove its associated git repository from .git/shards/"
			echo
			echo "Arguments:"
			echo " shard_path       Path of the shard to remove"
			echo " more_shard_path  Same as shard_path"
			exit 0
		esac

		for SHARDSPEC in "$@"; do
			while read -r SHARDPATH; do
				(( $(get-shard-exists "$SHARDPATH") == 1 )) || (echo "There is no shard for path $SHARDPATH" && exit 1)

				while read -r CFG; do
					git-main config --local --unset "$CFG"
				done <<< "$(git-main config --local -l | grep -oE "^shards.$SHARDPATH.[^=]+")"

				rm -rf "$MAINREPOGIT/shards/$SHARDPATH"

			done <<< "$(expand-shard-match "$SHARDSPEC")"
		done
		;;

	files)
		case "${1:-help}" in -h|--help|help)
			echo "Usage: git shard files shard_path command [path_spec]"
			echo
			echo "Limits a shard to only track a list of files and directories."
			echo "Once at least one path is defined, the shard repository will ignore any other file."
			echo
			echo "Arguments:"
			echo " shard_path  Path of the shard"
			echo " command     either add, remove, get, set"
			echo " path_spec   Path to a file or directory. Can contain wildcards for matching multiple files"
			exit 0
		esac
		SHARDPATH="$1"
		COMMAND="$2"
		VALUE="${3:-}"

		(( $(get-shard-exists "$SHARDPATH") == 1 )) || (echo "There is no shard for path $SHARDPATH" && exit 1)

		while read -r SHARDPATH; do
			case "$COMMAND" in
				get)
					git-main config --local "shards.$SHARDPATH.files"
					;;
				set)
					git-main config --local "shards.$SHARDPATH.files" "$VALUE"
					;;
				add)
					CURRVAL=$(git-main config --local "shards.$SHARDPATH.files" || true)
					if [ -n "$CURRVAL" ]; then
						CURRVAL="$CURRVAL:"
					fi
					git-main config --local "shards.$SHARDPATH.files" "$CURRVAL$VALUE"
					;;
				remove)
					CURRVAL=$(git-main config --local "shards.$SHARDPATH.files" || true)
					CURRVAL=$(echo "$CURRVAL" | tr ":" "\n" | grep -vxF "$VALUE" | tr "\n" ":" | sed 's/:$//')
					git-main config --local "shards.$SHARDPATH.files" "$CURRVAL"
					;;
				*)
					echo "Unknown sub-command $COMMAND"
					exit 1
					;;
			esac

		done <<< "$(expand-shard-match "$SHARDPATH")"
		;;

	commit)
		case "${1:-help}" in -h|--help|help)
			echo "Usage: git shard commit [options]"
			echo
			echo "Copy commits from the main repository to each shard"
			echo
			echo "Arguments:"
			echo " options  Forwarded to the 'git commit' command"
			exit 0
		esac
		migrate-commits "$@"
		;;

	exec)
		case "${1:-help}" in -h|--help|help)
			echo "Usage: git shard exec shard_path [git_args]"
			echo
			echo "Executes a git command inside a shard (do not repeat the 'git' command)"
			echo
			echo "Arguments:"
			echo " shard_path  Path of the shard. '*' for all shards"
			echo " git_args    Args passed to the git command to execute"
			exit 0
		esac

		SHARDPATH="$1"
		shift

		if [[ "$SHARDPATH" == "*" ]]; then
			# Exec for each shard
			while read -r SHARDPATH; do
				echo "=> $SHARDPATH"
				git-sub "$SHARDPATH" "$@" || true
			done <<< "$(get-shards-path)"
		else
			# Exec for a specific shard
			if (( ! $(get-shard-exists "$SHARDPATH") )); then
				echo "No shard for $SHARDPATH"
				exit 1
			fi
			git-sub "$SHARDPATH" "$@"
		fi
		;;

	*)
		echo "Unknown command: $SUBCOMMAND"
		exit 1

esac

