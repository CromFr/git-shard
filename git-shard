#!/bin/bash
# shellcheck disable=SC2155

set -euo pipefail
# set -x


MAINREPO=$(git rev-parse --show-toplevel)
MAINREPOGIT=$(git rev-parse --git-dir)
if [[ "${OS:-}" == "Windows_NT" ]]; then
	MAINREPO="$(cygpath -u "$MAINREPO")"
	MAINREPOGIT="$(cygpath -u "$MAINREPOGIT")"
fi
function get-shard-repo-path(){
	local shard_path="$1"
	if [[ "$shard_path" == "." ]]; then
		echo "$MAINREPOGIT/shards/__root"
	else
		echo "$MAINREPOGIT/shards/$shard_path"
	fi
}

function git-main(){
	git --git-dir="$MAINREPOGIT" "$@"
}
function git-sub(){
	local shard_path="$1"
	shift
	git --git-dir="$(get-shard-repo-path "$shard_path")" --work-tree="$MAINREPO/$shard_path" "$@"
}

function get-shards-path(){
	while read -r SHARD; do
		echo "$SHARD" | sed -E 's|^shards\.(.*)\.upstream=.*|\1|'
	done < <(git-main config --local -l | grep -E '^shards\..*\.upstream' || true)
}

function get-shard-exists(){
	local shard_path="$1"
	if [[ "$shard_path" == "*" ]]; then
		if git-main config --local -l | grep -E '^shards\..*\.upstream' >/dev/null; then
			echo 1
		else
			echo 0
		fi
	else
		if git-main config --local "shards.$shard_path.upstream" >/dev/null; then
			echo 1
		else
			echo 0
		fi
	fi
}
function get-oldest-main-commit(){
	# TODO: find a cleaner solution for returning the oldest commit
	if [ -z "$1" ] || { [ -n "$2" ] && [ -n "$(git-main log "$1..$2")" ] ; }; then
		echo "$1"
	else
		echo "$2"
	fi
}
function get-latest-main-commit(){
	# TODO: find a cleaner solution for returning the latest commit
	if [ -z "$1" ] || { [ -n "$2" ] && [ -n "$(git-main log "$1..$2")" ] ; }; then
		echo "$2"
	else
		echo "$1"
	fi
}
function get-latest-shard-commit(){
	local shard_path="$1"
	shift
	# TODO: find a cleaner solution for returning the latest commit
	if [ -z "$1" ] || { [ -n "$2" ] && [ -n "$(git-sub "$shard_path" log "$1..$2")" ] ; }; then
		echo "$2"
	else
		echo "$1"
	fi
}

function get-shard-last-mainref(){
	local shard_path="$1"

	local last_inspected=$(git-main config --local "shards.$shard_path.commit")
	local last_commited_in_shard=$(git-sub "$shard_path" show HEAD -q --format='%b' 2>/dev/null | grep -oE "^SHARD-MAINREF: \w+$" | cut -d ' ' -f 2 || true)
	local last_commited_in_main=$(git-main log -q --format='%b%H' 2>/dev/null | grep -E "^SHARD-COMMIT: $shard_path:\w+$" -A1 | head -n2 | tail -n1 || true)

	local latest=$(get-latest-main-commit "$last_inspected" "$last_commited_in_shard")
	get-latest-main-commit "$latest" "$last_commited_in_main"
}
function get-shard-last-shardref(){
	local shard_path="$1"

	local last_commited_in_shard=$(git-sub "$shard_path" log -q --format='%b%H' 2>/dev/null | grep -E "^SHARD-MAINREF: \w+$" -A1 | head -n2 | tail -n1)
	local last_commited_in_main=$(git-main log -q --format='%b' 2>/dev/null | grep -oE "^SHARD-COMMIT: $shard_path:\w+$" | cut -d ':' -f 3)

	get-latest-shard-commit "$shard_path" "$last_commited_in_shard" "$last_commited_in_main"
}

function expand-shard-match(){
	if [[ "$1" == "*" ]]; then
		get-shards-path
	else
		echo "$1"
	fi
}

function append-patch-message(){
	local blanklines=0
	local forward=0
	while IFS= read -r line; do
		if (( forward == 0 )); then
			if [ -z "$line" ]; then
				blanklines=$((blanklines + 1))
				if (( blanklines == 2)); then
					echo -e "$1"
					echo
					forward=1
				fi
			else
				blanklines=0
			fi
		fi
		echo "$line"
	done
}

function migrate-commits(){

	local range=""
	local commit_args=()

	while (( $# > 0 )); do
		case "$1" in
			--range)
				shift
				range="$1"
				;;
			*)
				commit_args+=("$1")
				;;
		esac

		shift
	done


	if [ -z "$range" ]; then
		# Find earliest commit
		local oldest=""
		while read -r SHARDPATH; do
			local COMMIT=$(get-shard-last-mainref "$SHARDPATH")

			if [ -z "$oldest" ] || [[ $(get-oldest-main-commit "$oldest" "$COMMIT") == "$COMMIT" ]]; then
				local oldest=$COMMIT
			fi
		done < <(get-shards-path)

		if [ -z "$oldest" ]; then
			range="HEAD^-"
		else
			range="$oldest^..HEAD"
		fi

	else
		# use provided range
		if [[ "$range" != *..* ]]; then
			range="$range^-"
		else
			range="$range"
		fi
	fi


	local commits_to_inspect=$(git-main log --format="%H" "$range" | tac)
	if [ -z "$commits_to_inspect" ]; then
		echo "Not commits to replicate on shards"
		exit 0
	fi

	# Stash changes if any
	if [ -n "$(git-main status --porcelain)" ]; then
		git-main stash push -u -m "Pre git-shard commit cleaning"
		trap "git-main stash pop -q" EXIT
	fi

	local mainrepo_branch=$(git-main rev-parse --abbrev-ref HEAD)


	# Checkout and replicate each commit in each shard
	for HASH in $commits_to_inspect; do
		echo "=========================================="
		echo "Copying commit $(git-main show -s --format='"%s" (%h)' "$HASH") to shards"
		echo "=========================================="
		git-main checkout "$HASH" 2>/dev/null

		local shard_path
		while read -r shard_path; do
			echo "=> $shard_path"
			if [ ! -d "$shard_path" ]; then
				echo "  Shard path is not a directory / does not exist"
				continue
			fi

			local shard_tracking_branch=$(git-main config --local "shards.$shard_path.branch")
			if [[ "$shard_tracking_branch" != "$mainrepo_branch" ]]; then
				echo "  Not affected (the shard tracks $shard_tracking_branch, not $mainrepo_branch)"
				continue
			fi

			local shard_commit=$(get-shard-last-mainref "$shard_path")
			if [[ -z "$shard_commit" ]]; then
				# First commit of the shard. Add everything
				local files=$(git-main config --local "shards.$shard_path.files" || true)
				if [ -n "$files" ]; then
					while read -r file; do
						git-sub "$shard_path" add "$file"
					done < <(tr ":" "\n" <<< "$files")
				else
					git-sub "$shard_path" add .
				fi

				git-sub "$shard_path" commit \
					--message="$(printf "Initial shard commit\n\nSHARD-MAINREF: %s" "$HASH")" \
					"${commit_args[@]}"
			else
				# Patch current shard repo
				if [[ "$HASH" == "$shard_commit" || "$(get-latest-main-commit "$shard_commit" "$HASH")" != "$HASH" ]]; then
					echo "  Commit already copied"
				else
					local patch=$(git-main format-patch --patch --no-stat --stdout --relative="$shard_path" "$HASH^-")
					if [ -z "$patch" ]; then
						echo "Not affected by changes"
						git-main config --local "shards.$shard_path.commit" "$HASH"
					else
						# Filter to apply the patch only to shard files
						local am_args=()
						local files=$(git-main config --local "shards.$shard_path.files" || true)
						if [ -n "$files" ]; then
							while read -r file; do
								am_args+=("--include=$file")
							done < <(tr ":" "\n" <<< "$files")
						fi

						# Reset the shard as a clean state
						git-sub "$shard_path" reset --hard >/dev/null
						git-sub "$shard_path" clean -f >/dev/null

						# Apply commit
						echo "$patch" \
							| append-patch-message "SHARD-MAINREF: $HASH" \
							| git-sub "$shard_path" am "${am_args[@]}" "${commit_args[@]}"
					fi
				fi
			fi

			# Update last inspected commit for shard
			git-main config --local "shards.$shard_path.commit" "$HASH"
		done < <(get-shards-path)
	done

	if [ -n "$mainrepo_branch" ]; then
		git-main checkout "$mainrepo_branch"
	fi
}

SUBCOMMAND="${1:-help}"
case "$SUBCOMMAND" in -h|--help|help)
	echo "Usage: git shard subcommand [options]"
	echo
	echo "Available subcommand:"
	echo " init   Register a directory as a shard and initialize/clone its associated git repository"
	echo " list   List all registered shards"
	echo " remove Un-register shards"
	echo " files  Limit an existing shard to a set of files and directories"
	echo " push   Copy commits from the main repository to each shard"
	echo " pull   Copy commits from a given shard into the main repository"
	echo " exec   Executes a git command inside a shard (do not repeat the 'git' command)"
	echo " help   Display this message"
	exit 0
esac

shift

case "$SUBCOMMAND" in
	init)
		BRANCH=$(git-main rev-parse --abbrev-ref HEAD)
		UPSTREAM=""
		SHARDPATH=""

		while (( $# > 0 )); do
			case "$1" in
				-h|--help)
					echo "Usage: git shard init [options] shard_path"
					echo
					echo "Register a directory as a shard and initialize/clone its associated git repository."
					echo "The shard is versioned using a bare repository stored in .git/shards/"
					echo
					echo "Arguments:"
					echo " shard_path       Path of the directory to track for creating the shard from"
					echo
					echo "Options:"
					echo " --upstream URI   Git clone URI if the shard repository is already versioned somewhere"
					echo " --branch BRANCH  Branch of the main repository that will be bound to the master branch of the shard. Defaults to the current branch of the main repository."
					exit 0
					;;
				--origin)
					shift
					UPSTREAM="$1"
					;;
				--branch)
					shift
					BRANCH="$1"
					;;
				*)
					if [ -z "$SHARDPATH" ]; then
						SHARDPATH="$1"
					else
						echo "Too many shard_path arguments"
						exit 1
					fi
					;;
			esac

			shift
		done

		# Assertions
		[ -d "$SHARDPATH" ] || (echo "$SHARDPATH does not exist / is not a directory" && exit 1)
		(( $(get-shard-exists "$SHARDPATH") == 0 )) || (echo "A shard already exists for path $SHARDPATH" && exit 1)

		SHARDPATH=$(realpath --relative-to="$MAINREPO" "$SHARDPATH")
		SHARDSTORPATH="$(get-shard-repo-path "$SHARDPATH")"

		# Clone/create shard repository
		mkdir -p "$SHARDSTORPATH"
		if [[ "$UPSTREAM" != "" ]]; then
			git clone --bare "$UPSTREAM" "$SHARDSTORPATH"

			LAST_MAIN_COMMIT=$(git-sub "$SHARDPATH" show HEAD -q --format='%b' | grep -oE "^SHARD-MAINREF: \w+$" | cut -d ' ' -f 2)
			git-main config --local "shards.$SHARDPATH.commit" "$LAST_MAIN_COMMIT"
		else
			git init --bare "$SHARDSTORPATH"
			git-main config --local "shards.$SHARDPATH.commit" ""
		fi

		# Add shard to git config
		git-main config --local "shards.$SHARDPATH.upstream" "$UPSTREAM"
		git-main config --local "shards.$SHARDPATH.branch" "$BRANCH"

		echo "Added shard $SHARDPATH"

		CURR_BRANCH="$(git-main rev-parse --abbrev-ref HEAD)"
		if [[ "$CURR_BRANCH" != "$BRANCH" ]]; then
			echo "Note: you are not currently on the tracked branch '$CURR_BRANCH' for this shard."
			echo "Execute \`git checkout '$BRANCH'\` to switch to the associated branch."
		fi
		;;

	list)
		while read -r SHARD_PATH; do
			echo "$SHARD_PATH=>$(git-main config --local --get "shards.$SHARD_PATH.upstream")@$(git-main config --local --get "shards.$SHARD_PATH.branch")"
		done < <(get-shards-path)
		;;

	remove)
		case "${1:-help}" in -h|--help|help)
			echo "Usage: git shard remove shard_path [more_shard_path...]"
			echo
			echo "Un-register one or more shards and remove its associated git repository from .git/shards/"
			echo
			echo "Arguments:"
			echo " shard_path       Path of the shard to remove"
			echo " more_shard_path  Same as shard_path"
			exit 0
		esac

		for SHARDSPEC in "$@"; do
			while read -r SHARDPATH; do
				(( $(get-shard-exists "$SHARDPATH") == 1 )) || (echo "There is no shard for path $SHARDPATH" && exit 1)

				rm -rf "$(get-shard-repo-path "$SHARDPATH")"
				git config --local --remove-section "shards.$SHARDPATH"

			done < <(expand-shard-match "$SHARDSPEC")
		done
		;;

	files)
		case "${1:-help}" in -h|--help|help)
			echo "Usage: git shard files shard_path command [path_spec]"
			echo
			echo "Limits a shard to only track a list of files and directories."
			echo "Once at least one path is defined, the shard repository will ignore any other file."
			echo
			echo "Arguments:"
			echo " shard_path  Path of the shard"
			echo " command     either add, remove, get, set"
			echo " path_spec   Path to a file or directory. Can contain wildcards for matching multiple files"
			exit 0
		esac
		SHARDSPEC="$1"
		COMMAND="$2"
		VALUE="${3:-}"

		(( $(get-shard-exists "$SHARDSPEC") == 1 )) || (echo "There is no shard for path $SHARDSPEC" && exit 1)

		while read -r SHARDPATH; do
			case "$COMMAND" in
				get)
					git-main config --local "shards.$SHARDPATH.files"
					;;
				set)
					git-main config --local "shards.$SHARDPATH.files" "$VALUE"
					;;
				add)
					CURRVAL=$(git-main config --local "shards.$SHARDPATH.files" || true)
					if [ -n "$CURRVAL" ]; then
						CURRVAL="$CURRVAL:"
					fi
					git-main config --local "shards.$SHARDPATH.files" "$CURRVAL$VALUE"
					;;
				remove)
					CURRVAL=$(git-main config --local "shards.$SHARDPATH.files" || true)
					CURRVAL=$(echo "$CURRVAL" | tr ":" "\n" | grep -vxF "$VALUE" | tr "\n" ":" | sed 's/:$//')
					git-main config --local "shards.$SHARDPATH.files" "$CURRVAL"
					;;
				*)
					echo "Unknown sub-command $COMMAND"
					exit 1
					;;
			esac

		done < <(expand-shard-match "$SHARDSPEC")
		;;

	push)
		case "${1:-}" in -h|--help|help)
			echo "Usage: git shard push [options]"
			echo
			echo "Copy commits from the main repository to each shard"
			echo
			echo "Arguments:"
			echo " options  Forwarded to the 'git commit' command"
			exit 0
		esac
		migrate-commits "$@"
		;;

	pull)
		SHARDSPEC=""
		AM_ARGS=()
		RANGE=""
		while (( $# > 0 )); do
			case "$1" in
				-h|--help)
					echo "Usage: git shard pull shard_path [options]"
					echo
					echo "Copy commits from the given shard into the main repository"
					echo
					echo "Arguments:"
					echo " shard_path Path of the shard. '*' for all shards"
					echo " options    Forwarded to the 'git am' command"
					echo
					echo "Options:"
					echo " --range RANGE  Shard commits to copy. Cannot be set with '*' shard_path. If not provided, automatically detects missing commits."
					echo " *              Other options are forwarded to the 'git am' command"
					exit 0
					;;
				--range)
					shift
					RANGE="$1"
					;;
				*)
					if [ -z "$SHARDSPEC" ]; then
						SHARDSPEC="$1"
					else
						AM_ARGS+=("$1")
					fi
					;;
			esac
			shift
		done

		if [[ -n "$RANGE" && "$SHARDSPEC" == "*" ]]; then
			echo "Cannot use --range with '*' shards."
			exit 1
		fi

		# Loop over each shard spec
		while read -r SHARDPATH; do

			if [ -z "$RANGE" ]; then
				# Detect range from commits
				SHARD_COMMIT="$(get-shard-last-shardref "$SHARDPATH")..HEAD"
			else
				# use provided range
				SHARD_COMMIT="$RANGE"
			fi

			while read -r COMMITHASH; do
				# Reproduce commit in main repo using patch files
				echo "=========================================="
				echo "Copying commit $(git-main show -s --format='"%s" (%h)' "$COMMITHASH") from $SHARDPATH to main repo"
				echo "=========================================="

				git-sub "$SHARDPATH" format-patch --patch --no-stat --stdout "$COMMITHASH^-" \
					| append-patch-message "SHARD-COMMIT: $SHARDPATH:$COMMITHASH" \
					| git-main am --directory="$SHARDPATH" "${AM_ARGS[@]}"

			done < <(git-sub "$SHARDPATH" log --format="%H" "$SHARD_COMMIT" | tac)
		done < <(expand-shard-match "$SHARDSPEC")
		;;

	exec)
		case "${1:-help}" in -h|--help|help)
			echo "Usage: git shard exec shard_path [git_args]"
			echo
			echo "Executes a git command inside a shard (do not repeat the 'git' command)"
			echo
			echo "Arguments:"
			echo " shard_path  Path of the shard. '*' for all shards"
			echo " git_args    Args passed to the git command to execute"
			exit 0
		esac

		SHARDPATH="$1"
		shift

		if [[ "$SHARDPATH" == "*" ]]; then
			# Exec for each shard
			while read -r SHARDPATH; do
				echo "=> $SHARDPATH"
				git-sub "$SHARDPATH" "$@" || true
			done < <(git-shards-path)
		else
			# Exec for a specific shard
			if (( ! $(get-shard-exists "$SHARDPATH") )); then
				echo "No shard for $SHARDPATH"
				exit 1
			fi
			git-sub "$SHARDPATH" "$@"
		fi
		;;

	*)
		echo "Unknown command: $SUBCOMMAND"
		exit 1

esac

